{
  "name": "Delux",
  "tagline": "Beautiful, light and simple state manager inspired by Redux",
  "body": "<h1>\r\n    <img\r\n        src=\"https://cdn.rawgit.com/aniddan/delux/master/assets/delux.svg\"\r\n        height=\"32\"\r\n    />\r\n    Delux\r\n</h1>\r\n\r\nBeautiful, light and simple state manager inspired by Redux\r\n\r\n```JavaScript\r\nimport Store from 'delux';\r\n\r\nlet store = new Store ();\r\n\r\nstore.tasks = new Store.Collection ({tasks: []});\r\n\r\nstore.tasks.on('addTask', (tasks, action) => tasks.concat({\r\n    name: action.payload,\r\n    completed: false\r\n}));\r\n\r\nstore.observe('tasks', (state) => console.log(state.tasks));\r\n\r\nstore.dispatch({\r\n    type: 'addTask',\r\n    payload: 'Try Delux'\r\n});\r\n```\r\n## Motivation\r\n\r\n- In Flux there's a design flaw: it's hard to manage several stores.\r\n- So came Redux with one store.\r\n- But: Redux lacks a defined API\r\n\r\n## Features\r\n\r\n- [Immutable][Immutability in JavaScript]\r\n- [Promise Based][Promise]\r\n- [Extendible classes][Subclassing]\r\n- [Flux Standard Actions][FSA]\r\n- [Ordered middlewares][Express Middlewares]\r\n- [No switches or combinations required][Redux Reducers]\r\n\r\n## API Reference\r\n\r\n### Store\r\n\r\nThe Store holds the whole application state and it's mutation logic.\r\n\r\n##### Create a Store\r\n\r\n```JavaScript\r\nlet store = new Store();\r\n```\r\n\r\n#### Description\r\n\r\nStores are objects whose prototype has methods to mutate there state. The Store's state is hold in [Collections](#Collection) assigned to it.\r\n\r\n#### Store instances\r\n\r\n##### Properties\r\n\r\n###### Store.prototype.state\r\n\r\nObject with mutations of the collections' states.\r\n\r\n##### Methods\r\n\r\n###### Store.prototype.dispatch()\r\n\r\nDispatches a [Flux Standard Action][FSA] on the state.\r\n\r\n```JavaScript\r\nstore.dispatch({\r\n    type: <string | symbol>,\r\n    payload: <object>\r\n    error: <boolean>,\r\n    meta: <any>\r\n});\r\n```\r\n\r\n**Returns**\r\n\r\nA promise which resolves to the the mutated store state.\r\n\r\n###### Store.prototype.observe()\r\n\r\nAdds an observer for mutations in the store's collections\r\n\r\n```JavaScript\r\nstore.observe(['collectionName'], (state) => {\r\n\r\n});\r\n```\r\n\r\n**Parameters**\r\n\r\n- **names | name** - array of collection names or a single name to observe for state mutation\r\n- **observer** - a function that with a given state mutation receives the name of the changed collection and it's new state. The arguments to the function are as follows:\r\n\r\n| Name       | Supplied Value               |\r\n|------------|----------------------------- |\r\n| state      | Store.prototype.state alias  |\r\n\r\n##### Store.prototype.use()\r\n\r\nAdds a middlware to the action resolution process\r\n\r\n```JavaScript\r\nstore.use(middleware|type|{type: middleware}, <middleware>);\r\n```\r\n\r\n**Parameters**\r\n\r\n- **middlware** - a function that mutates a given action. If it returns a Promise the store will wait for the promise to complete before passing it to the next middleware and the reducers.\r\n\r\n- **type** - action type to apply middleware on.\r\n\r\n##### Store.prototype.queue()\r\n\r\nAdds a function to the store's execute queue\r\n\r\n```JavaScript\r\nstore.queue(() => callback());\r\n```\r\n\r\n##### Store.prototype.state.get()\r\n\r\nGet specific collection's state from the store's state\r\n\r\n```JavaScript\r\nlet partialState = store.state.get(collectionNames);\r\n```\r\n\r\n###### Parameters\r\n\r\n### Collection\r\n\r\nCollections holds a sub-state (similar to [Flux Stores][Flux Stores]) and it's mutation logic\r\n\r\n#### Assign a Collection\r\n\r\n```JavaScript\r\nstore.collectionName = new Collection (init);\r\n```\r\n\r\n**Parameters**\r\n\r\n- **init** - The initial state of the collection\r\n\r\n#### Collection instances\r\n\r\n##### Properties\r\n\r\n###### Collection.prototype.state\r\n\r\nReflects the collections's state\r\n\r\n###### Collection.prototype.reducers\r\n\r\nReflects the collections's reducers\r\n\r\n###### Collection.prototype.observers\r\n\r\nReflects the collections's observers\r\n\r\n##### Methods\r\n\r\n###### Collection.prototype.on()\r\n\r\nAttach a reducer to received actions ([Node style][Node EventEmitter On])\r\n\r\n```JavaScript\r\nstore.collectionName.on(['actionType'], (state, action) => {\r\n\r\n});\r\n```\r\n\r\n**Parameters**\r\n\r\n- **types | type** - array of action types or a single type to apply the reducer on\r\n- **reducer** - a function that with a given action mutates the collection state and returns the new state. The arguments to the function are as follows:\r\n\r\n\r\n| Name   | Supplied Value        |\r\n|--------|-----------------------|\r\n| state  | The collection state  |\r\n| action | The dispatched action |\r\n\r\n[Delux Logo]: https://cdn.rawgit.com/aniddan/delux/master/assets/delux.svg\r\n[Immutability in JavaScript]: https://www.sitepoint.com/immutability-javascript/\r\n[FSA]: https://github.com/acdlite/flux-standard-action\r\n[Promise]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n[Subclassing]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Sub_classing_with_extends\r\n[Flux Stores]: https://facebook.github.io/flux/docs/overview.html#stores\r\n[Redux Reducers]: http://redux.js.org/docs/basics/Reducers.html\r\n[Express Middlewares]: https://www.safaribooksonline.com/blog/2014/03/10/express-js-middleware-demystified/\r\n[Node EventEmitter On]: https://nodejs.org/api/events.html#events_emitter_on_eventname_listener",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}